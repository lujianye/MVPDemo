# MVPDemo
Mvp Demo

> 问题一：问什么会采用泛型设计

    问题1: 存在多个presenter，需要定义多次，即有多少个需要绑定多少个.存在代码冗余的问题  
    解决方案：抽象一个父类  
    
    问题2：父类中的交互接口需要动态使用，不能写死  
    解决方案：泛型设计，即定义时不需要指定类型
    
    问题3：存在多个activity时，需要绑定多次
    解决方案：抽象父类+泛型设计（动态指定）
    
> 问题二：为什么使用代理模式？

    问题1：V层包含了Activity，Fragment，View,ViewGroup等等模块，如果在MVP中使用这些模块，
         会存在代码冗余的问题
         例如：生命周期的处理，数据缓存的处理，业务逻辑处理不同模块有差别
        
    解决方案：高度抽象设计->代理模式->双重代理模式
            第一重代理：解决生命周期和数据缓存的问题
                核心：代理的是activity的生命周期
                角色一：目标接口（备注：定义了Activity生命周期方法）-> ActivityMvpDelegate
                角色二：目标对象（备注：实现了Activity中MVP功能）-> ActivityMvpDelegateImpl
                角色三：代理对象（备注：在Activity里面回调生命周期方法）-> MvpActivity
            第二重代理：高度抽象MVP绑定与解绑问题
                核心：实现MVP高度绑定和解绑抽象（抽取出公共功能）
                角色一：目标接口（备注：定义了绑定和解绑标准）-> MvpCallback
                角色二：目标对象（备注：具体实现MVP绑定和解绑）-> MvpActivity
                角色三：代理对象（备注：代理实现回调我们绑定和解绑操作）
                    注意：客户端不需要关系如何调用，只需要关心如何实现（实现API即可）
            最后：关联两个代理->实现->测试
> 代理模式：基础知识

    种类：静态代理、动态代理
        静态代理根据场景划分：保护代理、虚代理等
        动态代理：动态创建代理类
    设计模式结构：
        代理模式结构：类结构
        核心角色3个
            角色一：目标接口
            角色二：目标对象
            角色三：代理对象
        举例说明：我要买一个手机，我让我的朋友代购，寄给我
            角色一：目标接口 -> 买手机的动作或行为（抽象->目标接口）
            角色二：目标对象 -> 我
            角色三：代理对象 -> 代理商->朋友